<!DOCTYPE html>
<html>
<head>
  <title>SceneryMan</title>
  <style type="text/css" src="sceneryMan.css"></style>
</head>
<body>
  <script type="text/javascript">
    function rgbToHex(r,g,b){
      return '#' + componentToHex(r) + componentToHex(g) + componentToHex(b)
    }

    function componentToHex(c) {
      c = c < 255 ? c : 255 
      var hex = c.toString(16)
      return hex.length == 1 ? "0" + hex : hex
    }

  </script>

  <script type="module">
    import * as THREE from './three.module.js'
    import { OrbitControls } from './OrbitControls.js'
    import { Shape } from './Shape.js'
    import { Cube } from './Cube.js'

    var shapes = {}
    var currentShapeId = null

    var renderer = new THREE.WebGLRenderer()
    renderer.autoClear = false
    renderer.setSize( window.innerWidth, window.innerHeight )
    document.body.appendChild( renderer.domElement )
    
    var camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
    camera.position.set( 0, 0, 0 );
    var controls = new OrbitControls( camera, renderer.domElement );
    controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 1;
    controls.maxDistance = 500;
    controls.maxPolarAngle = Math.PI / 2;


    var scene = new THREE.Scene()
    scene.background = new THREE.Color( '#444488' )
    
    var geometry = new THREE.BoxGeometry( 0.2, 0.2, 0.2 );
    var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
    let cube = new THREE.Mesh( geometry, material );
    cube.position.set(0,0.8,3)
    scene.add( cube );

    var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 )
    scene.add( directionalLight )


    function randomSign(){
      return Math.random() > 0.5 ? 1 : -1
    }

    function addRandomCube(){
      let geometry = new THREE.BoxGeometry( 0.1, 0.1, 0.1 );
      let material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
      let newcube = new THREE.Mesh( geometry, material );
      newcube.position.set(randomSign() * Math.random()*3, randomSign() * Math.random()*6, randomSign() * Math.random()*3)
      scene.add( newcube );
    }

    function newCube(){
      // let geometry = new THREE.BoxGeometry( 0.1, 0.1, 0.1 );
      let shape = new Cube(0.1,0.1,0.1)
      shapes[shape.id] = shape
      // shapes[shape.id].mesh.position.set(randomSign() * Math.random()*3, randomSign() * Math.random()*6, randomSign() * Math.random()*3)

      currentShapeId = shape.id

      scene.add(shapes[shape.id].mesh)

    }

    function animate() {
      // addRandomCube()
      controls.update()
      requestAnimationFrame( animate )
      // draw de cool scene
      renderer.render( scene, camera )
    }

    function onDocumentKeyDown(event){
      if(event.key == 'z'){
        newCube()
      }


      if(event.key == "ArrowLeft" || event.key == "ArrowUp" || event.key == "ArrowRight" || event.key == "ArrowDown"){
        shapes[currentShapeId].move(event.key)
      }

      if(event.key == "q"){
        shapes[currentShapeId].rotateX(0.1)
      } else if(event.key == "a"){
        shapes[currentShapeId].rotateX(-0.1)
      } else if(event.key == "w"){
        shapes[currentShapeId].rotateY(0.1)
      } else if(event.key == "s"){
        shapes[currentShapeId].rotateY(-0.1)
      } else if(event.key == "e"){
        shapes[currentShapeId].rotateZ(0.1)
      } else if(event.key == "d"){
        shapes[currentShapeId].rotateZ(-0.1)
      }

      if(event.key == "r"){
        shapes[currentShapeId].scaleX(0.1)
      } else if(event.key == "f"){
        shapes[currentShapeId].scaleX(-0.1)
      } else if(event.key == "t"){
        shapes[currentShapeId].scaleY(0.1)
      } else if(event.key == "g"){
        shapes[currentShapeId].scaleY(-0.1)
      } else if(event.key == "y"){
        shapes[currentShapeId].scaleZ(0.1)
      } else if(event.key == "h"){
        shapes[currentShapeId].scaleZ(-0.1)
      }

      if(event.key == "p"){
        console.log( shapes[currentShapeId].print() )
      }


      if(event.key == "["){
        console.log( 'brack left', shapes )
        let keys = Object.keys(shapes)
        let currentKeyIndex = keys.indexOf( currentShapeId )
        currentShapeId = keys[ currentKeyIndex - 1 ]

        if(!currentShapeId){
          // go to right side
          currentShapeId = keys[keys.length - 1]
        } 

      } else if(event.key == "]"){
        console.log( 'brack rioght', shapes )
        
        let keys = Object.keys(shapes)
        let currentKeyIndex = keys.indexOf( currentShapeId )
        currentShapeId = keys[ currentKeyIndex + 1 ]

        if(!currentShapeId){
          // go to right side
          currentShapeId = keys[0]
        }
      }
    }

    document.addEventListener("keydown", onDocumentKeyDown, false);

    animate()

  </script>



</body>
</html>