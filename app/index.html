<!DOCTYPE html>
<html>
<head>
  <title>SceneryMan</title>
   <link rel="stylesheet" href="SceneryMan.css">
</head>
<body>
  <script type="text/javascript">
    function rgbToHex(r,g,b){
      return '#' + componentToHex(r) + componentToHex(g) + componentToHex(b)
    }

    function componentToHex(c) {
      c = c < 255 ? c : 255 
      var hex = c.toString(16)
      return hex.length == 1 ? "0" + hex : hex
    }

  </script>

  <script type="module">
    import * as THREE from './three.module.js'
    import { OrbitControls } from './OrbitControls.js'
    import { Shape } from './Shape.js'
    import { Cube } from './Cube.js'
    import { Sphere } from './Sphere.js'

    var shapes = {}
    var currentShapeId = null

    var renderer = new THREE.WebGLRenderer()
    renderer.autoClear = false
    renderer.setSize( window.innerWidth, window.innerHeight )
    document.body.appendChild( renderer.domElement )
    
    var camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.001, 10000 );
    camera.position.set( 0, 0, 0 );
    
    // orbits
    var controls = new OrbitControls( camera, renderer.domElement );
    controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 1;
    controls.maxDistance = 500;
    controls.maxPolarAngle = Math.PI / 2;

    var keyStates = {}

    var scene = new THREE.Scene()
    scene.background = new THREE.Color( '#333333' )
    
    // onelight
    var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.4 )
    directionalLight.position.set(0.5,1,0.5)
    scene.add( directionalLight )

    var light = new THREE.HemisphereLight( 0xffffff, 0x000000, 1 );
    scene.add( light );

    // var directionalLight2 = new THREE.DirectionalLight( 0xffffff, .5 )
    // scene.add( directionalLight2 )



    /////// WORKFLOW STUFF
    function randomSign(){
      return Math.random() > 0.5 ? 1 : -1
    }

    function addRandomCube(){
      let geometry = new THREE.BoxGeometry( 0.1, 0.1, 0.1 );
      let material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
      let newcube = new THREE.Mesh( geometry, material );
      newcube.position.set(randomSign() * Math.random()*3, randomSign() * Math.random()*6, randomSign() * Math.random()*3)
      scene.add( newcube );
    }

    function newCube(){
      // let geometry = new THREE.BoxGeometry( 0.1, 0.1, 0.1 );
      let shape = new Cube(0.1,0.1,0.1)
      shapes[shape.id] = shape
      // shapes[shape.id].mesh.position.set(randomSign() * Math.random()*3, randomSign() * Math.random()*6, randomSign() * Math.random()*3)

      currentShapeId = shape.id
      scene.add(shapes[shape.id].mesh)
    }

    function newSphere(){
      let shape = new Sphere(0.1)
      shapes[shape.id] = shape
      currentShapeId = shape.id

      scene.add(shapes[shape.id].mesh)
    }

    function printShapes(){
      let shapeIds = Object.keys(shapes)
      let outputStr = "var group = new THREE.Group()\n\n"
      let shapeId
      for(var i=0; i<shapeIds.length; i++){
        shapeId = shapeIds[i]
        // console.log( 'geo', shapes[shapeId].mesh.geometry )
        outputStr += shapes[shapeId].print()
      }

      outputStr += "scene.add(group)\n"

      return outputStr
    }

    /////// DUH
    function animate() {
      // addRandomCube()
      controls.update()
      
      drawShapesList()

      requestAnimationFrame( animate )
      // draw de cool scene
      renderer.render( scene, camera )
    }

    /////// UI
    function drawShapesList() {
      let str = ""
      let shapeIds = Object.keys(shapes)
      let shapeId

      let selected
      for(var i=0; i<shapeIds.length; i++){
        shapeId = shapeIds[i]

        if(shapeId == currentShapeId){
          selected = "*"
        } else {
          selected = ""
        }

        str += "<h2 style='color: " + shapes[shapeId].color + ";'>" + selected + shapes[shapeId].name + "</h2>"
      }

      // console.log( 'shape list', str )
      document.getElementById("shape-list").innerHTML = str
    }

    function onDocumentKeyDown(event){
      keyStates[event.key] = true
      // console.log( 'keys', event.key, true )

      if(event.key == 'z'){
        newCube()
      } else if(event.key == 'x'){
        newSphere()
      }

      if(event.key == "ArrowLeft" || event.key == "ArrowUp" || event.key == "ArrowRight" || event.key == "ArrowDown"){

        let shift = keyStates["Shift"]  
        shapes[currentShapeId].move(event.key, shift)
      }

      if(event.key == "q"){
        shapes[currentShapeId].rotateX(0.1)
      } else if(event.key == "a"){
        shapes[currentShapeId].rotateX(-0.1)
      } else if(event.key == "w"){
        shapes[currentShapeId].rotateY(0.1)
      } else if(event.key == "s"){
        shapes[currentShapeId].rotateY(-0.1)
      } else if(event.key == "e"){
        shapes[currentShapeId].rotateZ(0.1)
      } else if(event.key == "d"){
        shapes[currentShapeId].rotateZ(-0.1)
      }

      if(event.key == "r"){
        shapes[currentShapeId].scaleX(0.1)
      } else if(event.key == "f"){
        shapes[currentShapeId].scaleX(-0.1)
      } else if(event.key == "t"){
        shapes[currentShapeId].scaleY(0.1)
      } else if(event.key == "g"){
        shapes[currentShapeId].scaleY(-0.1)
      } else if(event.key == "y"){
        shapes[currentShapeId].scaleZ(0.1)
      } else if(event.key == "h"){
        shapes[currentShapeId].scaleZ(-0.1)
      }

      if(event.key == "p"){
        // console.log( shapes[currentShapeId].print() )

        console.log( 'output ', printShapes() )
        document.getElementById("output").value = printShapes()
      }

      if(event.key == "Delete"){
        shapes[currentShapeId].remove(scene)
        delete shapes[currentShapeId]
      }


      if(event.key == "["){
        console.log( 'brack left', shapes )
        let keys = Object.keys(shapes)
        let currentKeyIndex = keys.indexOf( currentShapeId )
        currentShapeId = keys[ currentKeyIndex - 1 ]

        if(!currentShapeId){
          // go to right side
          currentShapeId = keys[keys.length - 1]
        } 

      } else if(event.key == "]"){
        console.log( 'brack rioght', shapes )
        
        let keys = Object.keys(shapes)
        let currentKeyIndex = keys.indexOf( currentShapeId )
        currentShapeId = keys[ currentKeyIndex + 1 ]

        if(!currentShapeId){
          // go to right side
          currentShapeId = keys[0]
        }
      }
    }

    function onDocumentKeyUp(event){
      keyStates[event.key] = false
      // console.log( 'keysU', event.key, false )
    }

    document.addEventListener("keydown", onDocumentKeyDown, false);
    document.addEventListener("keyup", onDocumentKeyUp, false);

    animate()

  </script>

  <div id="shape-list"></div>
  <textarea id="output" type="text" name="whatever"></textarea>


</body>
</html>